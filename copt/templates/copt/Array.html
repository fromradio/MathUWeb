{%extends "home/base.html"%}

{%block header%}{{chapter.name}}{%endblock%}

{%block content%}
<div class ="chaptername">
    Array
</div>

<div class ="introduction">
    <p class = "introduction"> <span>Array</span> describes a base class for basic dense data types used in open source library COPT like 'VectorBase' and 'MatrixBase'. The 'Array' can be independent or referred to an existing 'Array'. This class derives directly from another basic type called <span>DataObject</span>. <span>Array</span> takes <span>scalar</span>, <span>index</span> and <span>SizeAtCompileTime</span> as template. </p>
</div>

<div class = "detail">
    <div class = "definition">
	    Array()
    </div>
    <div class = "description">
        The default constructor of 'Array'. A zero-dimensional array will be generated as default.
    </div>
</div>

<div class = "detail">
    <div class = "definition">
	    Array(const index size, const scalar *data = nullptr, const index inter = 1)
    </div>
    <div class = "description">
        Constructor for generating a standard 'Array' with a specific size, a given array and the interval of the pointer.
        <p class= "paragraph">
        Parameters:
        </p>
        <p class = "arg"><span>size:</span> The size of the 'Array'</p>
        <p class = "arg"><span>data:</span> The pointer to the array of data. 'nullptr' is used as default. When 'nullptr' is used, all elements will be initialized as zero.</p>
        <p class = "arg"><span>inter:</span> The interval of the pointer. '1' is used as default.</p>
    </div>
</div>

<div class = "detail">
    <div class = "definition">
        Array (const scalar *data, const index inter = 1)
    </div>
    <div class = "description">
        Constructor for generating a non-dynamic 'Array' with a given array and the interval of the pointer.
        <p class= "paragraph">
        Parameters:
        </p>
        <p class = "arg"><span>data:</span> The pointer to the array of data.</p>
        <p class = "arg"><span>inter:</span> The interval of the pointer. '1' is used as default.</p>
    </div>
</div>

<div class = "detail">
    <div class = "definition">
	    Array(const index size, const referred_array&amp arr, scalar *data, const index inter = 1)
    </div>
    <div class = "description">
        Construct an 'Array' which refers to existing data. The size of the data and the pointer to the data are given. Besides the interval of 'Array' should be specified too.
        <p class= "paragraph">
        Parameters:
        </p>
        <p class = "arg"><span>size:</span> The size of the 'Array'.</p>
        <p class = "arg"><span>arr:</span> The trait of referred 'Array'. A consideration of C++ feature.</p>
        <p class = "arg"><span>data:</span> The pointer to the array of data. 'nullptr' is used as default.</p>
        <p class = "arg"><span>inter:</span> The interval of the pointer. '1' is used as default.</p>
    </div>
</div>

<div class = "detail">
    <div class = "definition">
        Array(const referred_array&amp arr, scalar *data, const index inter = 1)
    </div>
    <div class = "description">
        Construct a non-dynamic 'Array' which refers to existing data. The pointer to the data is given. Besides the interval of 'Array' should be specified too.
        <p class= "paragraph">
        Parameters:
        </p>
        <p class = "arg"><span>arr:</span> The trait of referred 'Array'. A consideration of C++ feature.</p>
        <p class = "arg"><span>data:</span> The pointer to the array of data. 'nullptr' is used as default.</p>
        <p class = "arg"><span>inter:</span> The interval of the pointer. '1' is used as default.</p>
    </div>
</div>

<div class = "detail">
    <div class = "definition">
	    Array(const Array&amp arr)
    </div>
    <div class = "description">
        Copy constructor from a given 'Array' <span>arr</span>. The array will automatically be a reffered 'Array' if <span>arr</span> is also one. Both 'Array's point to the same data. Otherwise the data will be copied.
        <p class= "paragraph">
        Parameters:
        </p>
        <p class = "arg"><span>arr:</span> The given 'Array'.</p>
    </div>
</div>

<div class = "detail">
    <div class = "definition">
	    virtual ~Array()
    </div>
    <div class = "description">
        The deconstructor of 'Array'. The constructed data will be automatically deconstructed.
    </div>
</div>

<div class = "detail">
    <div class = "definition">
	    void clear()
    </div>
    <div class = "description">
        This function is used to clear the 'Array'.
    </div>
</div>

<div class = "detail">
    <div class = "definition">
	    scalar *dataPtr()
    </div>
    <div class = "description">
        Access to data pointer for modification or other operations.
        <p class= "paragraph">
        Returns:
        </p>
        <p class = "arg"> The pointer to the data</p>
    </div>
</div>

<div class = "detail">
    <div class = "definition">
	    const scalar *dataPtr() const
    </div>
    <div class = "description">
        Const access to data pointer.
        <p class= "paragraph">
        Returns:
        </p>
        <p class = "arg"> The pointer to the data</p>
    </div>
</div>

<div class = "detail">
    <div class = "definition">
	    void copy(const Array&amp arr)
    </div>
    <div class = "description">
        Copy from another 'Array'. Unlike copy constructor, the 'Array' will not be a referred one.
        <p class= "paragraph">
        Parameters:
        </p>
        <p class = "arg"><span>arr:</span> The 'Array' to be copied</p>
    </div>
</div>

<div class = "detail">
    <div class = "definition">
	    void swap(Array&amp arr)
    </div>
    <div class = "description">
        Swap two 'Array's.
        <p class= "paragraph">
        Parameters:
        </p>
        <p class = "arg"><span>arr:</span> The given 'Array' to swap with the original one.</p>
    </div>
</div>

<div class = "detail">
    <div class = "definition">
	    const index&amp size() const
    </div>
    <div class = "description">
        Get the size of the 'Array'.
        <p class= "paragraph">
        Returns:
        </p>
        <p class = "arg"> The size of the 'Array'</p>
    </div>
</div>

<div class = "detail">
    <div class = "definition">
	    bool isReferred() const
    </div>
    <div class = "description">
        Judge whether the 'Array' is referred.
        <p class= "paragraph">
        Returns:
        </p>
        <p class = "arg"> True if the 'Array' is referred, false otherwise.</p>
    </div>
</div>

<div class = "detail">
    <div class = "definition">
	    index interval() const
    </div>
    <div class = "description">
        Get the interval of the 'Array'.
        <p class= "paragraph">
        Returns:
        </p>
        <p class = "arg"> The interval of the 'Array'</p>
    </div>
</div>

<div class = "detail">
    <div class = "definition">
	    iterator begin()
    </div>
    <div class = "description">
        Access to begin iterator.
        <p class= "paragraph">
        Returns:
        </p>
        <p class = "arg"> Begin iterator</p>
    </div>
</div>

<div class = "detail">
    <div class = "definition">
        const_iterator begin() const
    </div>
    <div class = "description">
        Const access to begin iterator.
        <p class= "paragraph">
        Returns:
        </p>
        <p class = "arg"> Begin iterator</p>
    </div>
</div>

<div class = "detail">
    <div class = "definition">
        iterator end()
    </div>
    <div class = "description">
        Access to end iterator.
        <p class= "paragraph">
        Returns:
        </p>
        <p class = "arg"> End iterator</p>
    </div>
</div>

<div class = "detail">
    <div class = "definition">
        const_iterator end() const
    </div>
    <div class = "description">
        Const access to end iterator.
        <p class= "paragraph">
        Returns:
        </p>
        <p class = "arg"> End iterator</p>
    </div>
</div>

<div class = "detail">
    <div class = "definition">
        void reset(const index size, const index inter = 1)
    </div>
    <div class = "description">
        Reset the 'Array' even if it is a referred one. Notice that size specified 'Array' is not able to be resized.
        <p class= "paragraph">
        Parameters:
        </p>
        <p class = "arg"><span>size:</span> New size of the 'Array'</p>
        <p class = "arg"><span>inter:</span> The interval of the pointer. '1' is used as default.</p>
    </div>
</div>

<div class = "detail">
    <div class = "definition">
	    void setArray(const index size, const scalar *data, const index inter = 1)
    </div>
    <div class = "description">
        Set the 'Array' with given size and data. Notice that size specified 'Array' is not able to be resized. Referred 'Array' is not allowed to be reset, either.
        <p class= "paragraph">
        Parameters:
        </p>
        <p class = "arg"><span>size:</span> New size of the 'Array'</p>
        <p class = "arg"><span>data:</span> The pointer to the array of data.</p>
        <p class = "arg"><span>inter:</span> The interval of the pointer. 1 is used as default.</p>
    </div>
</div>

<div class = "detail">
    <div class = "definition">
	    void setArray(const scalar *data)
    </div>
    <div class = "description">
        Set the 'Array' with given data if the size is specified at compile time. 
        <p class= "paragraph">
        Parameters:
        </p>
        <p class = "arg"><span>data:</span> The given data</p>
    </div>
</div>

<div class = "detail">
    <div class = "definition">
        template&ltint Size&gt</br>
        void setFromArray(const Array&ltscalar,index,Size&gt&amp arr)
    </div>
    <div class = "description">
        Set the 'Array' with given 'Array'. Notice that size specified 'Array' is not able to be resized. Referred 'Array' is not allowed to be reset, either.
        <p class= "paragraph">
        Parameters:
        </p>
        <p class = "arg"><span>arr:</span> The given 'Array'</p>
    </div>
</div>

<div class = "detail">
    <div class = "definition">
	    void setReferredArray(const index size, scalar *data, const index inter = 1)
    </div>
    <div class = "description">
        Set a referred 'Array' with given size and data. 
        <p class= "paragraph">
        Parameters:
        </p>
        <p class = "arg"><span>size:</span> New size of the 'Array'</p>
        <p class = "arg"><span>data:</span> The pointer to the array of data.</p>
        <p class = "arg"><span>inter:</span> The interval of the pointer. '1' is used as default.</p>
    </div>
</div>

<div class = "detail">
    <div class = "definition">
	    bool isValid() const
    </div>
    <div class = "description">
        Judge whether the 'Array' is valid. The 'Array' is valid if and only if the template is valid scalar type: 'float', 'double', 'std::complex&ltfloat&gt' or 'std::complex&ltdouble&gt'
        <p class= "paragraph">
        Returns:
        </p>
        <p class = "arg"> True if the 'Array' is valid, false otherwise.</p>
    </div>
</div>

<div class = "detail">
    <div class = "definition">
	    scalar&amp operator[](index i)
    </div>
    <div class = "description">
        Matlib-like data access of 'Array'. User can use operator[] to access the (i+1)-th element of a given 'Array' <span>arr</span>. The syntax is simply <span>arr(i)</span> and out-of-range exception will be throwed if <span>i</span> is less than zero or no less than the size of <span>arr</span>. Note that the first element is with index 0 meaning that <span>i</span> is in range [0,size-1].
        <p class= "paragraph">
        Parameters:
        </p>
        <p class = "arg"><span>i:</span> The index number of the element we want to get</p>
        <p class= "paragraph">
        Returns:
        </p>
        <p class = "arg"> The (i+1)-th element of the 'Array'</p>
    </div>
</div>

<div class = "detail">
    <div class = "definition">
	    const scalar&amp operator[](index i) const
    </div>
    <div class = "description">
        Const access of element in 'Array'.
        <p class= "paragraph">
        Parameters:
        </p>
        <p class = "arg"><span>i:</span> The index number of the element we want to get</p>
        <p class= "paragraph">
        Returns:
        </p>
        <p class = "arg"> The (i+1)-th element of the 'Array'</p>
    </div>
</div>

<div class = "detail">
    <div class = "definition">
        Array&amp operator=(const Array&amp arr)
    </div>
    <div class = "description">
        Copy assignment of 'Array'. The functionality is the same as copy constructor. All data is copied.
        <p class= "paragraph">
        Parameters:
        </p>
        <p class = "arg"><span>arr:</span> The 'Array' to be copied</p>
        <p class= "paragraph">
        Returns:
        </p>
        <p class = "arg"> An 'Array' copied from the given 'Array'</p>
    </div>
</div>

<div class = "detail">
    <div class = "definition">
        friend std::ostream&amp operator&lt&lt(std::ostream&amp os, const Array&amp arr)
    </div>
    <div class = "description">
        Overload of output stream of 'Array'. The output form is like <span>[arr[0],arr[1],...,arr[size-1]]</span>.
        <p class= "paragraph">
        Parameters:
        </p>
        <p class = "arg"><span>os:</span> The standard stream</p>
        <p class = "arg"><span>arr:</span> The given 'Array'</p>
        <p class= "paragraph">
        Returns:
        </p>
        <p class = "arg"> The standard stream</p>
    </div>
</div>
{%endblock%}